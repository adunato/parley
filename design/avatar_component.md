# Avatar Management Component Design

**Objective:** To create a reusable UI component for displaying, uploading, and cropping character and persona avatars, replacing the current text-based URL input with a more interactive and user-friendly experience.

## 1. Component Reusability

The existing template file `templates/avatar-uploader.tsx` provides a comprehensive and self-contained solution for avatar management. It includes file/paste handling and a custom cropping dialog with advanced controls (zoom, rotation, flip). This template will be moved and adapted for application-wide use, avoiding the need for external dependencies.

## 2. Component Implementation

### New Component: `AvatarUploader`

-   **Action:** Move `templates/avatar-uploader.tsx` to `src/components/ui/avatar-uploader.tsx`.
-   **Review and Refactor:** The code from the template will be used as the foundation. Minor refactoring may be needed to align with the project's state management and coding standards.
-   **Props:** The component will be simplified to better fit the application's needs. The `forwardRef` and `useImperativeHandle` logic, while powerful, is not necessary for our use case. A simpler props interface will be used:
    ```typescript
    interface AvatarUploaderProps {
      currentAvatar: string; // The current avatar URL or data URL
      onAvatarChange: (newAvatarDataUrl: string) => void; // Callback to update the avatar
      size?: number; // Optional size for the avatar display
    }
    ```

### Key Features (from template)

-   **Display:** Renders the current avatar in a circular frame.
-   **Hover Controls:** On hover, it displays "Upload" and "Paste" buttons.
-   **File Handling:** Uses a hidden file input for uploads and a clever `contenteditable` div to capture pasted images.
-   **Custom Crop Dialog:** A feature-rich dialog allows users to:
    -   Move and resize the crop area.
    -   Zoom, rotate, and flip the image.
-   **Output:** After cropping, the component will generate a base64 data URL of the final, square avatar and pass it to the `onAvatarChange` callback.

## 3. Data Storage

-   The `Character` and `PlayerPersona` types in the Zustand store (`src/lib/store.ts`) will have their `avatar` field store the base64 data URL string generated by the component. This makes the avatar self-contained within the application state.

## 4. Integration into Character Configuration

-   **File:** `src/components/character-configuration.tsx`
-   **Implementation:**
    1.  The new `<AvatarUploader />` component will be added to the "Basic Information" card.
    2.  It will replace the existing `<Input />` field for the "Avatar URL".
    3.  The component will be rendered when the form is in edit mode (`isEditing` is true). When not in edit mode, a simple `<img>` tag will display the current avatar.
    4.  The `currentAvatar` prop will be bound to `displayCharacter.basicInfo.avatar`.
    5.  The `onAvatarChange` prop will be a function that calls `handleInputChange("basicInfo", "avatar", newAvatarDataUrl)`.

    **Example Snippet (Illustrative):**

    ```tsx
    // Inside the "Basic Information" CardContent in character-configuration.tsx

    <div className="space-y-2">
        <Label>Avatar</Label>
        {isEditing ? (
            <AvatarUploader
                currentAvatar={displayCharacter.basicInfo.avatar || ""}
                onAvatarChange={(newAvatar) => handleInputChange("basicInfo", "avatar", newAvatar)}
            />
        ) : (
            <img src={displayCharacter.basicInfo.avatar || "/placeholder.svg"} alt="Avatar" className="w-32 h-32 rounded-full object-cover" />
        )}
    </div>
    ```

## Benefits

-   **Leverages Existing Code:** Reuses a high-quality, feature-rich template, saving significant development time.
-   **No New Dependencies:** Avoids adding third-party libraries to the project.
-   **Superior UX:** Provides a modern, visual, and powerful way to manage avatars.
-   **Data Integrity:** Ensures all avatars are square and stores them directly in the application's state.