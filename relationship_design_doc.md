# Design Document: Player-Character Relationship System

## 1. Objective

This document outlines the design for implementing a new, dynamic player-character relationship system in the Parley text adventure game. The goal is to replace the current static `relationshipToPlayer` attribute with a more nuanced and dynamically generated set of relationship attributes, which will be determined via a dedicated API/LLM prompt when a character first encounters a player persona. This system will also be generalized to allow for future character-to-character relationships.

## 2. Current State Analysis

Currently, each `Character` object includes a `relationshipToPlayer` attribute, which is a simple object containing `affinity` (an integer) and `notes` (a string). This attribute is part of the `Character` interface and is generated along with the rest of the character's profile.

## 3. Proposed Data Model

The existing `relationshipToPlayer` attribute will be removed from the `Character` interface. A new, dedicated `Relationship` model will be introduced, defined as follows:

```typescript
export interface Relationship {
  closeness: number;    // An integer between -100 (emotionally distant or hostile) and 100 (deeply bonded and emotionally close)
  attraction: number;   // An integer between -100 (strong aversion or repulsion) and 100 (strong romantic or physical attraction)
  respect: number;      // An integer between -100 (complete distrust or contempt) and 100 (deep respect, trust, and admiration)
  engagement: number;   // An integer between -100 (disinterest or boredom) and 100 (high curiosity and emotional investment)
  stability: number;    // An integer between -100 (chaotic, volatile, unreliable relationship) and 100 (stable, consistent, and secure connection)
}
```

This `Relationship` data will be stored persistently in the Zustand store, separate from the `Character` and `PlayerPersona` objects. To allow for relationships between a character and multiple personas (and potentially between two characters in the future), it will be modeled as a nested `Map`:

`relationships: Map<string, Map<string, Relationship>>`

Where the outer map's key is the `characterId`, and the inner map's key is the `personaAlias`.

## 4. API Changes

### 4.1. Character Generation API (`/api/generate/character`)

The `relationshipToPlayer` attribute will be removed from the JSON structure generated by this API. The LLM prompt for character generation will be updated to no longer include instructions for generating this attribute.

### 4.2. New Relationship Generation API (`/api/generate/relationship`)

A new API endpoint will be created to dynamically generate the relationship between a character and a player persona.

*   **Endpoint:** `/api/generate/relationship`
*   **Method:** `POST`
*   **Request Body:**
    ```json
    {
      "characterId": "string",
      "personaAlias": "string",
      "worldDescription": "string", // Optional, for context
      "aiStyle": "string" // Optional, for context
    }
    ```
*   **Response Body:**
    ```json
    {
      "relationship": {
        "closeness": number,
        "attraction": number,
        "respect": number,
        "engagement": number,
        "stability": number
      }
    }
    ```
*   **LLM Prompt:** The LLM prompt for this API will instruct the model to generate the `closeness`, `attraction`, `respect`, `engagement`, and `stability` values based on the provided `characterId`, `personaAlias`, and optional `worldDescription` and `aiStyle`. The prompt will emphasize generating values within the specified range of -100 to 100.

## 5. UI Changes

### 5.1. Character Configuration (`src/components/character-configuration.tsx`)

*   **Removal of Old UI:** The input fields and display elements related to `displayCharacter.relationshipToPlayer.affinity` and `displayCharacter.relationshipToPlayer.notes` will be removed.
*   **Display of New Relationship:** New UI elements will be added to display the `closeness`, `attraction`, `respect`, `engagement`, and `stability` values for the currently selected character and the active player persona. These values will be retrieved from the new `relationships` map in the Zustand store.
*   **Trigger for Relationship Generation:** A button (e.g., "Generate Relationship" or "Meet Character") will be added to trigger the call to the `/api/generate/relationship` endpoint. This button will likely be placed in the character detail view and will be enabled when a character is selected.

## 6. Zustand Store (`src/lib/store.ts`) Changes

*   **Remove `relationshipToPlayer`:** The `relationshipToPlayer` property will be removed from the `Character` interface.
*   **Add `Relationship` Interface:** The new `Relationship` interface will be defined.
*   **Add `relationships` State:** A new state variable `relationships: Map<string, Map<string, Relationship>>` will be added to the `ParleyStore` interface and initialized as an empty `Map`.
*   **Add Actions:**
    *   `addRelationship(characterId: string, personaAlias: string, relationship: Relationship)`: To add a new relationship entry.
    *   `updateRelationship(characterId: string, personaAlias: string, relationship: Relationship)`: To update an existing relationship.
    *   `getRelationship(characterId: string, personaAlias: string): Relationship | undefined`: To retrieve a specific relationship.
    *   `deleteRelationship(characterId: string, personaAlias: string)`: To remove a relationship.

## 7. Implementation Steps (High-Level)

1.  **Update `src/lib/store.ts`:**
    *   Remove `relationshipToPlayer` from `Character` interface.
    *   Define `Relationship` interface.
    *   Add `relationships` state and its associated actions (`addRelationship`, `updateRelationship`, `getRelationship`, `deleteRelationship`).
2.  **Update Character Generation API:**
    *   Modify `src/app/api/generate/character/route.ts` to remove `relationshipToPlayer` from the generated JSON.
    *   Update `src/lib/prompts/generatorPrompts.ts` to reflect this change in `CHARACTER_JSON_STRUCTURE` and `generateCharacterPrompt`.
3.  **Create New Relationship Generation API:**
    *   Create `src/app/api/generate/relationship/route.ts` with the `POST` endpoint logic.
    *   Define a new prompt in `src/lib/prompts/generatorPrompts.ts` for relationship generation.
4.  **Update `src/components/character-configuration.tsx`:**
    *   Remove old `relationshipToPlayer` UI.
    *   Implement new UI to display `Relationship` attributes, fetching data using `getRelationship`.
    *   Add a button to trigger the new relationship generation API call and update the store using `addRelationship` or `updateRelationship`.
5.  **Testing:** Implement unit and integration tests for the new API and store actions.

## 8. Testing Considerations

*   **Unit Tests:**
    *   Test the new `addRelationship`, `updateRelationship`, `getRelationship`, and `deleteRelationship` actions in `src/lib/store.ts`.
    *   Test the new relationship generation API endpoint (`/api/generate/relationship`) to ensure it correctly calls the LLM and returns a valid `Relationship` object.
*   **Integration Tests:**
    *   Verify that the `character-configuration.tsx` component correctly displays the generated relationship data.
    *   Test the end-to-end flow of generating a character, then generating a relationship with a persona, and ensuring persistence across sessions.
